"use strict";(self.webpackChunkplayard_education=self.webpackChunkplayard_education||[]).push([[570],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),m=o,g=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return t?a.createElement(g,r(r({ref:n},c),{},{components:t})):a.createElement(g,r({ref:n},c))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var p=2;p<i;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3644:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var a=t(7462),o=t(3366),i=(t(7294),t(3905)),r=["components"],l={sidebar_label:"How to Create Your Own Game",sidebar_position:3,id:"pgeblog3",title:"How to Create Your Own Game",slug:"/howtocreateyourowngame"},s="How to Create Your Own Game",p={unversionedId:"playardGameEngine/pgeblog3",id:"playardGameEngine/pgeblog3",title:"How to Create Your Own Game",description:"The Playard Game Engine is a game engine based on the speed of the C++ and the flexibility of the XML. It allows you to make impressive games by shortening the development process. To make great games with the Playard Game Engine, you just need to download the source codes and include them in your program.",source:"@site/docs/playardGameEngine/howtocreateyourowngame.md",sourceDirName:"playardGameEngine",slug:"/howtocreateyourowngame",permalink:"/playard-education/docs/howtocreateyourowngame",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/playardGameEngine/howtocreateyourowngame.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_label:"How to Create Your Own Game",sidebar_position:3,id:"pgeblog3",title:"How to Create Your Own Game",slug:"/howtocreateyourowngame"},sidebar:"tutorialSidebar",previous:{title:"Why use Playard Game Engine ?",permalink:"/playard-education/docs/why-pge"},next:{title:"How Alignment Works In PGE ?",permalink:"/playard-education/docs/howalignmentworks"}},c={},u=[{value:"Workspace Setup",id:"workspace-setup",level:2},{value:"Downloading Playard Game Engine",id:"downloading-playard-game-engine",level:3},{value:"Via Github Version Control System (VCS)",id:"via-github-version-control-system-vcs",level:4},{value:"Via Code Button",id:"via-code-button",level:4},{value:"Via Download Link",id:"via-download-link",level:4},{value:"Project Structure",id:"project-structure",level:3},{value:"Game File Structure",id:"game-file-structure",level:3},{value:"Designing a Screen with XML",id:"designing-a-screen-with-xml",level:4},{value:"What Are Components and How to Use Them",id:"what-are-components-and-how-to-use-them",level:2},{value:"Layouts",id:"layouts",level:3},{value:"Points",id:"points",level:3},{value:"Rectangles",id:"rectangles",level:3},{value:"Circles",id:"circles",level:3},{value:"Triangles",id:"triangles",level:3},{value:"Texts",id:"texts",level:3}],d={toc:u};function m(e){var n=e.components,t=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"how-to-create-your-own-game"},"How to Create Your Own Game"),(0,i.kt)("p",null,"The Playard Game Engine is a game engine based on the speed of the C++ and the flexibility of the XML. It allows you to make impressive games by shortening the development process. To make great games with the Playard Game Engine, you just need to download the source codes and include them in your program."),(0,i.kt)("h2",{id:"workspace-setup"},"Workspace Setup"),(0,i.kt)("p",null,"In the Playard Game Engine, all games inherit from the Game class. A playard game should contain the following elements:"),(0,i.kt)("h3",{id:"downloading-playard-game-engine"},"Downloading Playard Game Engine"),(0,i.kt)("h4",{id:"via-github-version-control-system-vcs"},"Via Github Version Control System (VCS)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"git clone https://github.com/play-Ard/playard.git\n")),(0,i.kt)("h4",{id:"via-code-button"},"Via Code Button"),(0,i.kt)("p",null,"You can also download it as a .zip file by clicking the Code > Download ZIP button above."),(0,i.kt)("h4",{id:"via-download-link"},"Via Download Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/play-Ard/playard/archive/refs/heads/main.zip"},"Download Here")),(0,i.kt)("h3",{id:"project-structure"},"Project Structure"),(0,i.kt)("p",null,"The default Playard project structure includes a games folder. All games accessible from the main menu must be created in this folder."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\ud83d\udce6playard\n  \u2523 \ud83d\udcc2core\n  \u2523 \ud83d\udcc2modules\n  \u2523 \ud83d\udcc2games\n  \u2503 \u2517 \ud83d\udcdcExampleGame1.cpp\n  \u2503 \u2517 \ud83d\udcdcExampleGame2.cpp\n  \u2503 \u2517 \ud83d\udcdcExampleGame3.cpp\n  \u2517 \ud83d\udcdcmain.ino\n")),(0,i.kt)("p",null,"In Playard Game Engine, it is recommended to write visual designs in XML and game codes in C++. Although Playard is Arduino based, games should be programmed with .cpp files instead of .ino files. In this way, a Playard device can keep multiple games in its memory. Don't worry if the files are .cpp files instead of .ino. In fact, Playard's core software does most of the preprocessing you do while programming Arduino. However, if you need, you can use all the functions you used while programming the Arduino."),(0,i.kt)("h3",{id:"game-file-structure"},"Game File Structure"),(0,i.kt)("p",null,"A Playard game should contain the following elements."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Base XML design ",(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"(required)"))),(0,i.kt)("li",{parentName:"ol"},"Logo to show in the main menu ",(0,i.kt)("em",{parentName:"li"},"(64 x 48 White Bitmap)")," ",(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"(required)"))),(0,i.kt)("li",{parentName:"ol"},"A constructor that makes the necessary configurations ",(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"(required)"))),(0,i.kt)("li",{parentName:"ol"},"onCreate method to specify what should happen before the screen loads"),(0,i.kt)("li",{parentName:"ol"},"onStart method to specify what should happen when the game is just started ",(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"(required)"))),(0,i.kt)("li",{parentName:"ol"},"onUpdate method to decide what happens while the game is running ",(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"(required)"))),(0,i.kt)("li",{parentName:"ol"},"onExit method to run some commands like saving the current state of the game")),(0,i.kt)("p",null,"Let's create an example game called MyGame."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\ud83d\udce6playard\n  \u2523 \ud83d\udcc2core\n  \u2523 \ud83d\udcc2modules\n  \u2523 \ud83d\udcc2games\n  \u2503 \u2517 \ud83d\udcdcMyGame.cpp\n  \u2517 \ud83d\udcdcmain.ino\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include "../core/PlayardCore.h"\n\nclass MyGame : public Game\n{\npublic:\n    const unsigned char logo[384] PROGMEM = {}; /* LOGO AS BITMAP */\n    const char *xml = "";                       /* XML DESIGN */\n\n    GFXEngine *graphics;\n    Input *input;\n\n    MyGame(GFXEngine *_graphics, Input *_input) : Game(logo)\n    {\n        setXML(xml);\n        this->graphics = _graphics;\n        this->input = _input;\n    }\n\n    void onCreate() override\n    {\n        // Some codes to run before the screen loads\n    }\n\n    void onStart() override\n    {\n        // Codes to run as soon as the game starts\n    }\n\n    void onUpdate() override\n    {\n        // Codes that will work as long as the game continues\n    }\n\n    void onExit() override\n    {\n        // Codes that will work when the this->exit() method runs\n    }\n};\n')),(0,i.kt)("p",null,"Let's take a look at our example game.\nFirst we create a class called MyGame and this class should inherit from ",(0,i.kt)("strong",{parentName:"p"},"Game")," class. Then we define the logo of the game in bitmap format and the design template in xml format. Then you will learn how to convert your logo to bitmap format and your template to xml format."),(0,i.kt)("p",null,"A little below, we see that the graphics and input pointers are defined to reach the graphics and the inputs received from the user. We'll take a look at how to use them later."),(0,i.kt)("p",null,"Then, the necessary assignments are made in the constructor method."),(0,i.kt)("p",null,"Right after, we have onCreate, onStart, onUpdate, onExit methods. Every Playard game must override the onStart and onUpdate methods. We will look at the details of these methods later."),(0,i.kt)("img",{src:"images/lifecycle.png"}),(0,i.kt)("h4",{id:"designing-a-screen-with-xml"},"Designing a Screen with XML"),(0,i.kt)("p",null,"Playard supports working with multiple designs with built-in XML processor. XML designs must specified as constant char pointer (const char *)."),(0,i.kt)("h2",{id:"what-are-components-and-how-to-use-them"},"What Are Components and How to Use Them"),(0,i.kt)("p",null,"Components is one of the innovative solutions of the Playard Game Engine. On PGE, everything is produced and arranged in the form of components.Different components created for figures, texts and images are arranged in the background and displayed on the screen. Components thus provide a cleaner working environment for the programmer."),(0,i.kt)("p",null,"To access the components in our program we must load related XML string with function loadXML.  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"")),(0,i.kt)("h3",{id:"layouts"},"Layouts"),(0,i.kt)("p",null,'Layouts are components that can contain component types, including layouts. Components can be grouped with layouts so that items on the screen can be aligned relative to each other or moved together. Each component has a parent layout, and the position of each component must be specified relative to the position of its parent. A layout has some attributes like "x-position", "y-position", "visibility" etc.'),(0,i.kt)("p",null,"We can create a layout component in XML. It must has an ID."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<Main>\n  <Layout\n  id = 'mainLayout'\n  x-position = '128'\n  y-position = '64'>\n\n  </Layout>\n</Main>\n")),(0,i.kt)("p",null," And now we can access our ball by call our getPointByID function with defined ID."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'const char* main_xml =\n"<Main>"\n"  <Layout"\n"  id = \'mainLayout\'"\n"  x-position = \'128\'"\n"  y-position = \'64\'>"\n""\n"  </Layout>"\n"</Main>"\n""\n;\n\ngfxEngine.loadXML(main_xml);\nLayout* mainLayout = gfxEngine.findLayoutByID("mainLayout");\n')),(0,i.kt)("p",null,"If we want to move our mainLayout up by 5 pixels, all we have to do change its vertical position."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"mainLayout->setY(mainLayout->getY() - 5);\n")),(0,i.kt)("h3",{id:"points"},"Points"),(0,i.kt)("p",null,"Points are components that are represents the pixels on the screen."),(0,i.kt)("p",null,"To create a point all we need to do create a point tag and define an ID for it, in our mainLayout."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<Main>\n  <Layout\n    id = 'mainLayout'\n    x-position = '128'\n    y-position = '64'>\n    <Point id = 'point1' x-position='24' y-position='24'/>\n  </Layout>\n</Main>\n")),(0,i.kt)("p",null,"We can access our ball by call our getPointByID function with defined ID."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'const char* main_xml =\n"<Main>"\n"  <Layout"\n"  id = \'mainLayout\'"\n"  x-position = \'128\'"\n"  y-position = \'64\'>"\n"    <Point id = \'point1\' x-position=\'24\' y-position=\'24\'/>"\n"  </Layout>"\n"</Main>"\n;\n\ngfxEngine.loadXML(main_xml);\nPoint* point = gfxEngine.findPointByID("point1");\n')),(0,i.kt)("img",{src:"images/example_draw_pixel.png",height:"200"}),(0,i.kt)("p",null,"For an example, if we want to hide our new point component we need set its visibility to 0."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"point->setVisibility(0);\n")),(0,i.kt)("h3",{id:"rectangles"},"Rectangles"),(0,i.kt)("p",null,'Rectangles are components for displaying rectangles on the screen. They have arguments named "x-position", "y-position", "border-radius" etc.'),(0,i.kt)("p",null,"To display a rectangle on the screen, we need to create a rectangle tag in a layout."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<Main>\n  <Layout\n    id = 'mainLayout'\n    x-position = '128'\n    y-position = '64'>\n    <Rectangle id = 'rect' x-position='64' y-position='32' width='42' height='24' border-radius='4'/>\n  </Layout>\n</Main>\n")),(0,i.kt)("p",null,"We can access our ball by call our getRectangleByID function with defined ID."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"const char* main_xml =\n\"<Main>\"\n\"  <Layout\"\n\"    id = 'mainLayout'\"\n\"    x-position = '128'\"\n\"    y-position = '64'>\"\n\"    <Rectangle id = 'rect' x-position='64' y-position='32' width='42' height='24' border-radius='4'/>\"\n\"  </Layout>\"\n\"</Main>\"\n;\n\ngfxEngine.loadXML(main_xml);\nRectangle* rectangle = gfxEngine.getRectangleByID(\"rect\");\n")),(0,i.kt)("p",null,"Let's move our rectangle left by 10 pixels."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"rectangle->setX(rectangle->getX() + 10);\n")),(0,i.kt)("h3",{id:"circles"},"Circles"),(0,i.kt)("p",null,'We can draw circles on the screen with Circle components. A circle component has some attributes named "fill", "visibility", "radius" etc.'),(0,i.kt)("p",null,"We need to create a Circle tag in a layout first."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<Main>\n  <Layout\n    id = 'mainLayout'\n    x-position = '128'\n    y-position = '64'>\n    <Rectangle id = 'rect' x-position='64' y-position='32' width='42' height='24' border-radius='4'/>\n    <Circle id='ball' x-position='112' y-position='48' radius='2' fill='1'/>\n  </Layout>\n</Main>\n")),(0,i.kt)("p",null,"We can access our ball by call our getCircleByID function with defined ID."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"const char* game_xml =\n\"<Main>\"\n\"  <Layout\"\n\"    id = 'mainLayout'\"\n\"    x-position = '128'\"\n\"    y-position = '64'>\"\n\"    <Rectangle id = 'rect' x-position='64' y-position='32' width='42' height='24' border-radius='4'/>\"\n\"    <Circle id='ball' x-position='112' y-position='48' radius='2' fill='1'/>\"\n\"  </Layout>\"\n\"</Main>\"\n;\n\ngfxEngine.loadXML(game_xml);\nCircle* ball = getCircleByID(\"ball\");\n")),(0,i.kt)("p",null,"Let's enlarge our ball 1 pixel. We can increase radius of ball."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"ball->setRadius(ball->getRadius() + 1);\n")),(0,i.kt)("h3",{id:"triangles"},"Triangles"),(0,i.kt)("p",null,"We may want to create some arrow signs or hats in our game. At this point, triangle components come to our aid."),(0,i.kt)("p",null,"To draw a triangle on the screen, all we need to do is write a Triangle tag in our XML string."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<Main>\n  <Layout\n    id = 'mainLayout'\n    x-position = '128'\n    y-position = '64'>\n    <Rectangle id = 'rect' x-position='64' y-position='32' width='42' height='24' border-radius='4'/>\n    <Circle id='ball' x-position='112' y-position='48' radius='2' fill='1'/>\n    <Triangle id='arrow' x1='12' y1='24' x2='12' y2='36' x3='24' y3='36'/>\n  </Layout>\n</Main>\n")),(0,i.kt)("p",null,"We can access our arrow by call our getTriangleByID function with defined ID."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"const char* arrow_game_xml =\n\"<Main>\"\n\"  <Layout\"\n\"    id = 'mainLayout'\"\n\"    x-position = '128'\"\n\"    y-position = '64'>\"\n\"    <Rectangle id = 'rect' x-position='64' y-position='32' width='42' height='24' border-radius='4'/>\"\n\"    <Circle id='ball' x-position='112' y-position='48' radius='2' fill='1'/>\"\n\"    <Triangle id='arrow1' x1='12' y1='24' x2='12' y2='36' x3='24' y3='36'/>\"\n\"  </Layout>\"\n\"</Main>\"\n;\n\ngfxEngine.loadXML(arrow_game_xml);\nTriangle* arrow = gfxEngine.getTriangleByID(\"arrow\");\n")),(0,i.kt)("p",null,"If we want to hide when the arrow hits an enemy all we need to set its visibility to 0."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"if (hit) {\n  arrow->setVisibility(0);\n}\n")),(0,i.kt)("h3",{id:"texts"},"Texts"),(0,i.kt)("p",null,"We learned draw so many shapes on our screen. But we don't always want to draw a shape. Also we may need to show score or name on the screen. At this point text components are very useful."),(0,i.kt)("p",null,"We can create a new text by write a Text tag in our XML in the same way."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<Main>\n  <Layout\n    id = 'mainLayout'\n    x-position = '128'\n    y-position = '64'>\n    <Text id='score' x-position='8' y-position='8' value='0'/>\n  </Layout>\n</Main>\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'const char* score_xml =\n"<Main>"\n"  <Layout"\n"    id = \'mainLayout\'"\n"    x-position = \'128\'"\n"    y-position = \'64\'>"\n"    <Text id=\'scoreText\' x-position=\'8\' y-position=\'8\' value=\'0\'/>"\n"  </Layout>"\n"</Main>"\n;\n\ngfxEngine.loadXML(score_xml);\nText* scoreText = gfxEngine.getTextByID("scoreText")\n')),(0,i.kt)("p",null,"Let's increase our score by 1."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"score = 0;\nscoreText->setValue(score);\n\nscore++; // Increase score by 1\nscoreText->setValue(score);\n")))}m.isMDXComponent=!0}}]);